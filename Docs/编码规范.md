# 嵌入式单片机 C 代码规范与风格

## 代码行相关规范

1. 每一行的代码长度限制在 80 列。如果大于 80 列的话就要分成多行编写，并且在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要适当进行缩进与上一行代码对齐，如下所示：

```c
perm_count_msg.head.len = NO7_TO_STAT_PERM_COUNT_LEN
                          + STAT_SIZE_PER_FRAM * sizeof(_UL);

act_task_table[frame_id * STAT_TASK_CHECK_NUMBER + index].occupied
    = stat_poi[index].occupied;

if ((taskno < MAX_ACT_TASK_NUMBER)
    && (n7stat_stat_item_valid(stat_item)))
{
    ... /* program code */
}

report_or_not_flag = ((taskno < MAX_ACT_TASK_NUMBER)
                      && (n7stat_stat_item_valid(stat_item))
                      && (act_task_table[taskno].result_data != 0));

n7stat_str_compare((BYTE *) & stat_object,
                   (BYTE *) & (act_task_table[taskno].stat_object),
                   sizeof(STAT_OBJECT));
```

2. 相对独立的程序块之间、变量说明之后，必须加空行。函数之间，必须加空行。

不规范的写法：

```c
void funa(...)
{
    if (!valid_ni(ni))
    {
        ... /* program code */
    }
    repssn_ind = ssn_data[index].repssn_index;
    repssn_ni = ssn_data[index].ni;
    while(x == 0)
    {
        ... /* program code */
    }
}
void funb(...)
{
    ... /* program code */
}
```

应改为：

```c
void funa(...)
{
    if (!valid_ni(ni))
    {
        ... /* program code */
    }

    repssn_ind = ssn_data[index].repssn_index;
    repssn_ni = ssn_data[index].ni;

    while(x == 0)
    {
        ... /* program code */
    }
}

void funb(...)
{
    ... /* program code */
}
```

3. 不要把多个语句放到一行里面。一行只写一条语句，如下所示：

不规范的写法：

```c
a = x + y; b = x - y;
```

应改为：

```c
a = x + y;
b = x - y;
```

4. 不要在一行里面放置多个赋值语句。

不规范的写法：

```c
a = b = 0;
```

应改为：

```c
a = 0;
b = 0;
```

5. if、for、do、while、case、switch、default 等语句单独占用一行。且 if、for、do、while 等语句的执行语句部分无论多少都要加括号 {}。当且仅当 while 后为空，可以不加 {}。

不规范的写法：

```c
if (p_gpiox->IDR & pinx) return 1;
else return 0;
```

应改为：

```c
if (p_gpiox->IDR & pinx)
{
    return 1; /* pinx 的状态为 1 */
}
else
{
    return 0; /* pinx 的状态为 0 */
}
```

6. 对齐全部用空格，或者说用空格填充的 TAB 键。

用空格填充 TAB 是为了避免跨编译器、不同软件打开时的差异导致代码排版不一致的情况，详情见 2.1.1 节说明。

## 括号与空格

### 括号

代码中用到大括号 { 和 } 的地方，对于单片机开发来说，左括号 { 一律新起一行，且位于程序块开始的同一列。对于 Linux 开发，则允许 { 放在行尾。以单片机开发为例：

不规范的写法：

```c
for (...) {
    ... /* program code */
}

if (...)
{
    ... /* program code */
} else {
    ... /* program code */
}

void example_fun(void)
{
    ... /* program code */
}
```

应改为：

```c
for (...)
{
    ... /* program code */
}

if (...)
{
    ... /* program code */
}
else
{
    ... /* program code */
}

void example_fun(void)
{
    ... /* program code */
}
```

当 while 语句没有代码的时候，可以不用加 {}。但是，只要 while 有哪怕 1 条语句，就必须加 {}，如下所示：

不规范的写法：

```c
while (((RCC->CR & (1<<17)) == 0) && (retry < 0X7FFF)) { retry++; }
```

应改为：

```c
while (((RCC->CR & (1<<17)) == 0) && (retry < 0X7FFF))
{
    retry++;
}
```

while 后面没有代码的时候，可以不要 {}：

```c
while ((QUADSPI->SR & (1<<1)) == 0); /* 等待指令发送完成 */
```

### 空格

1. 在一些关键字后面要添加空格，如：if、switch、case、for、do、while。

但是不要在 sizeof、typeof、alignof 或者 __attribute__ 这些关键字后面添加空格。因为这些大多数后面都会跟着小括号，因此看起来像个函数，如：

```c
s = sizeof(struct file);
```

2. 如果要定义指针类型，或者函数返回指针类型时，* 应该放到靠近变量名或者函数名的一侧，而不是类型名，如：

```c
char *linux_banner;
unsigned long long memparse(char *ptr, char **retptr);
char *match_strdup(substring_t *s);
```

3. 二元或者三元操作符两侧都要加一个空格，例如下面所示操作符：

```
+ - * / % & | ^ < > = == != <= >= ?:
```

4. 一元操作符后不要加空格，如：

```
& * + - ~ ! sizeof typeof alignof __attribute__ defined
```

5. 后缀自加或者自减的一元操作符前后都不加空格，如：

```
++ --
```

6. . 和 -> 这两个结构体成员操作符前后不加空格。

7. 逗号、分号只在后面添加空格，如：

```c
int a, b, c;
```

8. 注释符 /* 和 */ 与注释内容之间要添加一个空格。

以上 8 点举例如下：

不规范的写法：

```c
void test_error(datax* p,int num,char baseval)
{
    int x1,x2;
    int t = 0;
    x1 = 32;
    x2 = 23;
    for(t=0;t<=num;t++) /*循环赋值*/
    {
        datax->buf[t] = x1*(x2+t)+baseval;
    }
}
```

应改为：

```c
void test_error(datax *p, int num, char baseval)
{
    int x1, x2;
    int t = 0;
    x1 = 32;
    x2 = 23;

    for (t = 0; t <= num; t++) /* 循环赋值 */
    {
        datax->buf[t] = x1 * (x2 + t) + baseval;
    }
}
```

## 标识符命名

### 命名规则

C 语言中的命名有多种风格，有 Unix 风格的、有 Windows 风格的、还有匈牙利命名法的等等。我们使用大部分软件工程师常用的命名方式（Unix 风格）：单词用小写，然后每个单词用下划线 _ 连接在一起。比如：read_adc_value()。因此在函数和变量的命名上就要使用此种方法。这也是 Linux 内核里面所使用的命名方法。

### 注意事项

1. 命名一定要清晰。清晰是首位，要使用完整的单词或者大家都知道的缩写，让别人一读就懂，避免不必要的误会。比如：

```c
int book_number;
int number_of_beautiful_girl;
```

2. 除了常用的缩写以外，不要使用单词缩写，更不要用汉语拼音。

3. 具有互斥意义的变量或者动作相反的函数应该使用互斥词组命名，如：

```
add/remove
begin/end
create/destroy
insert/delete
first/last
get/release
increment/decrement
put/get
add/delete
lock/unlock
open/close
min/max
old/new
start/stop
next/previous
source/target
show/hide
send/receive
source/destination
copy/paste
up/down
```

4. 如果是移植的其它的代码，比如驱动，命名风格应该和原风格一致。

5. 不要使用单字节命名变量，但是允许使用 i、j、k 这样的作为局部循环变量。

## 文件命名

文件统一采用小写命名。

## 变量命名

变量名一定要有意义，并且意义准确，单词都采用小写，用下划线 _ 连接。比如表示图书的数量的变量，就可以使用如下命名：

```c
int number_of_book;
```

不要采用匈牙利命名法，尽量避免使用全局变量。

另外，变量命名可以使用 g_、p_ 开头，来表示该变量是一个全局变量、指针等，可以提高代码的可读性。

我们规定数据类型简写 u8、u16、u32 等不再使用，统一改成更为规范的简写（stdint.h 中的类型）：

```c
int8_t   /* 8 位有符号 char 型 */
int16_t  /* 16 位有符号 short 型 */
int32_t  /* 32 位有符号 int 型 */
int64_t  /* 64 位有符号 long long 型（对 STM32 来说）*/
uint8_t  /* 8 位无符号 unsigned char 型 */
uint16_t /* 16 位无符号 unsigned short 型 */
uint32_t /* 32 位无符号 unsigned int 型 */
uint64_t /* 64 位无符号 unsigned long long 型（对 STM32 来说）*/
```

## 函数命名

和变量命名一样。

## 宏命名

对于数值等常量宏定义的命名，如非特殊情况，一般使用大写，单词之间使用下划线 _ 连接在一起。比如：

```c
#define PI_ROUNDED 3.14
```